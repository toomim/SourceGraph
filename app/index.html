<!DOCTYPE html>
<html>
  <head>
      <meta charset='utf-8'>
      <title>source-graph</title>
      <style type="text/css">
      </style>
  </head>
  <body>
  <div id="root"></div>
  <script>
    //////////////////////////////////////////////////////////////
    // Client Web Socket

    var ws = new WebSocket('ws://localhost:40510');

    ws.onopen = function () {
      console.log('websocket is connected ...');
      ws.send('connected');
    };

    ws.onmessage = function (ev) {
      console.log("Client message");
      const payload = {
        v: 1,
        source: "lalala"
      };

      ws.send(JSON.stringify(payload))
    };
  </script>
  <script>

    //////////////////////////////////////////////////////////////
    // Essential Variables

    // Q: How to create local state that mirrors the parent-child relationships?
    // const treeState = {};

    // Element IDs
    const rootId = 'root';
    const containerId = 'container';
    const tabcontainerId = 'tabs';
    const tab1Id = 'tab1';
    const panelcontainerId = 'panelcontainer';
    const panel1Id = 'panel1';

    //////////////////////////////////////////////////////////////
    // Element Style

    const containerStyle = 'width:100%; height:100%; position:absolute; background-color:blue; margin:-8px; overflow:hidden;';
     const tabcontainerStyle = 'width:200px; height:100%; position:relative; background-color: lightblue; float:left; border-right:solid; border-right-width:1px; border-color:black;';
    const tabStyle = 'width:100%; height:20px; position:relative; background-color:green; border-bottom:solid; border-bottom-width:1px;';
    const panelcontainerStyle = 'width: 400px; height:100%; position:relative; background-color:yellow; float:left; border-right:solid; border-right-width:1px; border-color:black; overflow:hidden;';
    const panelStyle = 'width:390px; height:100%; position:relative; background-color:orange; float:left; border-right:solid; border-right-width:1px;';

    //////////////////////////////////////////////////////////////
    // Element Helper Functions

    // Q: Can there be a general parent-child-appender?
    // function appendChildtoParent(parentId, childId, childStyle, childConstructor) {
    //   return;
    // }

    function makeBranch(element, id, style, children) {
      return {
        element: element,
        id: id,
        style: style,
        children: children
      }
    }

    const stateTree = makeBranch('div', containerId, containerStyle,
      [
        makeBranch('div', tabcontainerId, tabcontainerStyle,
          [
            makeBranch('div', tab1Id, tabStyle, []),
            makeBranch('div', tab1Id, tabStyle, []),
            makeBranch('div', tab1Id, tabStyle, [])
          ]
        ),
        makeBranch('div', panelcontainerId, panelcontainerStyle,
          [
            makeBranch('div', panel1Id, panelStyle, [])
          ]
        )
      ]
    );

    function renderTree(tree, rootId) {
      const parent = document.getElementById(rootId);
      const child = document.createElement(tree.element);
      const childId = tree.id;
      child.setAttribute('id', childId);
      child.setAttribute('style', tree.style);
      parent.appendChild(child);
      const children = tree.children;
      for (let x = 0; x < tree.children.length; x++) {
        const grandchildren = children[x];
        renderTree(grandchildren, childId);
      }
      return;
    }

    /*
    Writing Panel Elements:
    1. Elements:
      1. Metadata-Header (construct from a metadata-array)
      2. WriteArea
      3. Publish
    2. Functionality
      Following a publish OnClick event all the metadata and textarea values will be gather, organized, and sent over ws to api.js where they will be stored
     */

  </script>
  <script>
    //////////////////////////////////////////////////////////////
    // Display Logic

    renderTree(stateTree, rootId);

  </script>
  </body>
</html>

<!--
  TODO:
  1. Data Model: The UI should mirror the data model.

  Q: How will edits and references work?

  Source: {
    v: _version number_,
    metadata: {
      title
      authors
      creation_time
      publish_time
      tags
    },
    data: _text, image, video, audio_,
  }

  2. UI Box Container

  WritingPanel:
    <PanelContainer>
      <PanelHeader>
        <PanelBar/>
        <WriteMetadata/>
      </PanelHeader/>
      <WriteArea/>
      <Publish/>
      <Close/>
    </PanelContainer>

  ReadingPanel:
    <PanelContainer>
      <PanelHeader>
      <PanelBar/>
        <WriteMetadata/>
      </PanelHeader/>
      <ReadArea/>
      <Publish/>
      <Close/>
      <Timeline/>
    </PanelContainer>

  TabContainer:
  <TabContainer>
    <SortSomething (not sure yet)>
    <Close/Open/>
    <Tab>
      <Title>
      <Tags>
    </Tab>
  </TabContainer>

 Layout plan:
   <Container>
     <TabContainer>
      <Tab>
     </TabContainer>
     </PanelContainer/>
   </Container>

  3. Web Socket Model
    Plan 1: A web socket should correspond to each resource. Therefore a read and write panel should have a corresponding websocket. The read web socket will be used for creating a new source and for displaying related sources. The write web socket will be used for publishing resources and connecting resources.

    Plan 2: There is a single socket and all panels interact with it the same way, but with different resources. (this is probably better and simpler)


    ReadPanel Socket:


    WritePanel Socket:


 -->